# Tanks: Orchestra of War
## Описание проекта
Это небольшая 2D-аркада с видом сверху, рассчитанная на игру по сети с другими людьми. Каждому игроку под управление даётся танк. Цель игры - уничтожить танки других игроков и остаться в живых. Для помощи игрокам на карте периодически появляются специальные ящики-бонусы: 3 вида ящиков для смены оборудования танка и 1 ящик ремонтного набора. 

Ящики для смены оборудования позволяют игроку получить новый корпус, орудие или тип снарядов. В результате получается большое количество комбинаций, каждая из которых может найти своё применение в зависимости от ситуации. 

<img src="https://raw.githubusercontent.com/KeyJ148/TOW/217798b51c5c92f33d487d1c3744cfb83578f53c/1.png" alt="Tanks: Orchestra of War" width="270"/>  <img src="https://raw.githubusercontent.com/KeyJ148/TOW/217798b51c5c92f33d487d1c3744cfb83578f53c/2.png" alt="Tanks: Orchestra of War" width="270"/>  <img src="https://raw.githubusercontent.com/KeyJ148/TOW/217798b51c5c92f33d487d1c3744cfb83578f53c/3.png" alt="Tanks: Orchestra of War" width="270"/>

<details>
  <summary>Скриншоты</summary>
  <img src="https://github.com/KeyJ148/TOW/blob/217798b51c5c92f33d487d1c3744cfb83578f53c/1.png" alt="Tanks: Orchestra of War"/>  
  <img src="https://github.com/KeyJ148/TOW/blob/217798b51c5c92f33d487d1c3744cfb83578f53c/2.png" alt="Tanks: Orchestra of War"/>  
  <img src="https://github.com/KeyJ148/TOW/blob/217798b51c5c92f33d487d1c3744cfb83578f53c/3.png" alt="Tanks: Orchestra of War"/>
</details>

## Управление 
WS - движение вперёд/назад  
AD - поворот танка по оси  
ЛКМ - выстрел танка в направлении курсора  
1/2/3/4 - блокировать подбор ящиков (для корпуса/орудия/типа снаряда/ремонтного набора)  
F2 - информация о танке  
F3 - отладочная информация
### Только для одиночной игры
N - суицид  
T/G/B - сменить корпус, орудие или тип снарядов соответственно
H/F - восстановить 40% или 100% здоровья соответственно
V - максимизировать эффект вампиризма

## Техническая часть
Этот проект разработан на Java 17, с использованием библиотеки [LWJGL3](https://github.com/LWJGL/lwjgl3), позволяющей обращаться к функциям OpenGL 3.3 и [LeGUI](https://github.com/SpinyOwl/legui) для работы с интерфейсом.
Мы используем наш собственный [движок](https://github.com/KeyJ148/TOW/tree/develop/OrchEngine), который до версии [v4.2.0](https://github.com/KeyJ148/TOW/releases/tag/v4.2.0) находился в отдельном [репозитории](https://github.com/KeyJ148/OrchEngine).  
В проекте совмещается компонентно-ориентированный подход при разработке игровых объектов и сервисно-ориентированный подход для доступа к функциональным частям движка.
### Движок
###### Сервисные компоненты и DI
В движке используется библиотека PicoContainers для внедрения зависимостей и инверсии управления.  
При запуске движок автоматически сканирует все классы в указанном пакете, ищет наши аннотации EngineService, GameService и TestService, и добавляет эти классы в контекст.  
Контекст приложения разделен на несколько групп (в соответствие с родительским потоком) и каждая группа имеет свою область видимости сервисов. Это облегчает параллельный запуск нескольких игровых клиентов во время тестирования, каждый из которых имеет свой уникальный список контейнеров.  
Благодаря PicoContainers и нашей системе аннотаций, мы можем заменять одни сервисы на другие (тестовые) во время загрузки. Это позволяет, например, заменять сервисы RenderService, TextureService и подобные на заглушки, что полностью исключает использование OpenGL и позволяет проводить автоматическое тестирование на системах без монитора или видео-драйвера, например, в Jenkins.  
Настройка сервисов также доступна через ProfilesService, что позволяет включать/выключать и заменять сервисы с использованием переменных окружения.
###### Игровой цикл
Циклы обновления состояния игрового мира (update) и отрисовки изображения (render) выполняются строго друг за другом. Интерполяция позиции объектов для отрисовки без обновления состояния игрового мира не используется. При каждом обновлении мира в объекты передаётся количество наносекунд, прошедших с последнего обновления.  На основе этой величины рассчитываются изменения состояния объектов игрового мира (например, перемещение). Это делается, чтобы избежать рассинхронизации состояния игрового мира у клиентов с разной частотой кадров. Для ограничения частоты кадров используется вертикальная синхронизация. В настройках можно задать делитель вертикальной синхронизации: 0 - без ограничения, 1 - частота монитора, 2 - половина частоты монитора и т.д. Если вертикальная синхронизация не поддерживается драйверами видеокарты (например, в некоторых Unix системах), то в настройках можно задать ограничение частоты кадров, которое будет выполняться при помощи отправки в сон основного игрового потока. Реализация функции ограничения частоты кадров учитывает особенности остановки потока, из-за которых не гарантируется, что поток во время выйдет из сна, поэтому поток останавливается несколько раз на всё уменьшающиеся промежутки времени.  
###### Обработка игрового мира 
Игровой мир разделён на локации. В один момент времени может быть активна только одна локация. У объектов на активной локации вызываются функции update и render. С целью экономии ресурсов локация разбивается на чанки и содержит список видимых чанков, которые надо отрисовывать. Чанки за границей экрана обновляются только в случае, если на них есть активные объекты, для которых надо вызывать функцию update.
###### Ресурсы
Конфигурационные файлы разделены на 2 группы: внутренние и внешние. Внутренние конфигурационные файлы при сборке проекта сохраняются в jar-файле, к ним относятся пути к текстурам, звукам и т.д. Внешние конфигурационные файлы находятся в корне проекта, а при их удалении устанавливаются стандартные значения из внутренних конфигурационных файлов. Во внешних конфигурационных файлах хранятся пользовательские настройки звука, графики и т.д. Конфигурационные файлы представлены в формате JSON. Для работы с ними разработан класс, который при помощи дженериков позволяет целиком загрузить или сохранить данные из внутренних/внешних конфигурационных файлов в соответствующий объект.
###### Игровые объекты
Все объекты расположенные в локации наследуются от общего класса игровых объектов. Игровые объекты имеют функции update и render, вызываемые движком в соответствующий момент игрового цикла. До версии игры [2.0.0](https://github.com/KeyJ148/TOW/releases/tag/v2.0.0) класс игрового объекта имел сложную цепочку наследования, из-за которой были трудности с расширением его функционала при реализации конкретного игрового элемента. На данный момент при работе с игровыми объектами используется компонентно-ориентированный подход.  
Компоненты могут реализовывать интерфейсы Updatable, Drawable, Positionable, Collidable. В зависимости от реализованных интерфейсов игровой движок будет вызывать соответствующие функции у компонента каждый игровой тик.
###### Клиент-серверное взаимодействие
Для создания сервера в конструктор необходимо передать класс, который реализует функцию обработки клиентских сообщений. Сообщение содержит ID и данные, свойственные для указанного ID. Для подключения к серверу необходимо создать клиент, в который также передаётся класс, реализующий обработку полученных от сервера сообщений. При подключении клиента создаётся сразу два соединения: TCP и UDP. Несмотря на то, что TCP соединение настроено на наименьшие задержки (например, включена опция tcp_nodelay), в случае потери пакетов происходят достаточно долгие задержки. Поэтому для собтытий, критических к скорости и не критических к доставке пакетов (например, текущее положение игрока), используется протокол UDP.
###### Использование движка
Движок является фреймворком и при его использовании происходит инверсия управления. Для запуска необходимо реализовать несколько интерфейсов и передать их в функцию OrchEngine#start. Одним из этих интерфейсов является GameInterface, содержащий функции init, update и render. Init вызывается перед стартом основного игрового цикла, update и render - перед обновлением и отрисовкой игрового мира соответственно.  
Второй основной способ вмешаться в процесс игры - это создание игрового объекта и переопределение у него функций update и render, либо же переопределение этих функций у любого из компонентов игрового объекта.  
Третий способ - это создать класс с аннотацией GameService и тогда он будет автоматически добавлен в игровой контекст при запуске приложения. У этого класса можно переопределить функции start, stop и взаимодействовать с другими сервисами движка и игры.
### Игра
###### Снаряжение
В процессе игры игрок использует различное снаряжение: броню, оружие и снаряды. Добавление в игру снаряжения и его настройка были максимально упрощены. Свойства снаряжения описываются в конфигурационном файле. Свойства включают в себя как общие свойства для всего снаряжения определенного типа (например, скорость брони, маневренность, текстура и т.д.), так и специфичные для определенной механики (например, кол-во осколков у разрывного снаряда). При этом сама механика также описывается в конфигурационном файле. Для каждого типа снаряжения (броня, орудие, снаряд) создан родительский класс, от которого наследуются все классы различных механик. При подборе игроком ящика со снаряжением выбирается случайный конфигурационный файл из находящихся в папке с конфигурационными файлами данного снаряжения. Из этого файла считывается механика снаряжения, после чего при помощи рефлексии находится одноименный класс, который уже запрашивает параметры, специфичные для данной механики. Этот механизм позволил избавить от указания вручную большого количества связей между механиками, конфигурационными файлами, текстурами и т.д. Для добавления нового снаряжения в игру достаточно просто поместить один конфигурационный файл в соответствующую папку. Для добавления новой механики достаточно просто унаследовать новый класс от родительского класса и после этого эту механику можно указывать в любом конфигурационном файле.
###### Эффекты
В игре присутствует множество снаряжения, которое может одновременно влиять на одни и те же характеристики игрока. Причём снаряжение как добавляет/вычитает значение характеристики, так и влияет на неё в процентном соотношении. Чтобы упростить подсчёт влияния снаряжения на игрока, была разработана система эффектов. Любое событие, влияющее на игрока, накладывает на него соответствующий эффект. Эффект содержит описание всех изменений характеристик. Для подсчёта значения характеристики вначале просчитываются все аддитивные эффекты, потом - все процентные увеличения данной характеристики. Таким образом, классу игрока нет необходимости знать какие именно классы и механики накладывают на него эффекты.
###### Тестирование
Было разработано несколько интеграционных тестов, чтобы автоматически проверять работоспособность игры. Благодаря библиотеке PicoContainers и изоляции видимости сервисов в соответствие с ThreadGroup и родительским потоком, можно запустить несколько клиентов игры параллельно, прямо из одного теста. Поэтому были сделаны тесты, которые запускают несколько экземпляров игры, проверяют подключение игрока к серверу и прочие основные механизмы игрыю
### CI/CD
###### Jenkins
После коммита в этот репозиторий, с GitHub отправляется уведомление на Jenkins сервер. Jenkins билдит последний коммит из соответствующей ветки под различные ОС (Windows/Linux/Linux ARM/MacOS/MacOS ARM), прогоняет автотесты и выкладывает готовый билд на [сайт](https://tow.abro.cc/download/).